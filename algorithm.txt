Max-min fairness algorithm

------------------------------------------------------------------------
1. Traditional water-filling algorithm (just to give a basic idea)

Suppose N flows (whose paths are given), L links in the topology.

Flows: f_i, i=1,2,...N

Links: l_j, j=1,2,...L

Bandwidth constraints: b_j, j=1,2,...L

Rate (to be calculated): r_i, i=1,2,...N

Step 1: To build the flow-link mapping matrix, whose raw represents the flow and column represents the link. If f_i uses link l_j, then the element α(i,j)=1, else α(i,j)=0.

Step 2: To calculate n_j, which is the number of flows that use link l_j, i.e., the sum of column j.

Step 3: To calculate τ_j = b_j /n_j, which is the potential average bandwidth allocation of link l_j. If n_j is zero, we set τ_j to zero.

Step 4: Iteration.
while (j'|min τ_j (τ_j>0)!=null){
	Search j'|min τ_j (τ_j>0), so l_j' will be the bottleneck link. Without loss of generality, we assume that flows f_1, f_2,..., f_k are using link l_j'. Then we set the rates of r_1, r_2,..., r_k to τ_j'. 
	Next, we subtract f_1, f_2,..., f_k and l_j'. 
	Then we update the matrix and τ for the remaining links. 
	We iterate until all flows have bottleneck links. (j'|min τ_j (τ_j>0)=null)
}
See Example 1.
------------------------------------------------------------------------
2. Data volume assignment for new multiple-sources transfer

Suppose there is a new transfer request, who has two sources to choose. We use x (x<=1) to denote the prportion of data from source 1, so 1-x will be the proportion from source 2. We want to calculate both r_i and x.

Step 1: To build the flow-link mapping matrix, whose raw represents the flow and column represents the link. If f_i uses link l_j, then the element α(i,j)=1, else α(i,j)=0. For the new transfer n, it can have two flows, f_n1 and f_n2. The elements of these two flows will not be binary. For f_n1, if f_n1 uses link l_j, then the element α(n1,j)=x; for f_n2, if f_n2 uses link l_j, then the element α(n2,j)=1-x.

Step 2: To calculate n_j, which is the number of flows that use link l_j, i.e., the sum of column j. Here, n_j will not be an integer. It can be fractioanl. Precisely, n_j is a function of x, i.e., n_j(x).

Step 3: To calculate τ_j = b_j /n_j, which is the potential average bandwidth allocation of link l_j. If n_j is zero, we set τ_j to zero. Here, τ_j will become a function of x as well, τ_j(x) = b_j /n_j(x).

Step 4: Iteration.
while (j'|min τ_j (τ_j>0)!=null){
	Just as the traditional one, we try to find min τ_j(x).
	If min τ_j(x)==constant, then we do the same as the traditional one.
	Else, we find x|max {min τ_j(x)}. 
	Then we do the same thing as the traditional.
}

Here is a little bit hard to understand. Please read together with Example 2.
Note that if a transfer has more than 2 sources, we can use x1, x2, x3,...to denote the assignment, and it also can be solved.
------------------------------------------------------------------------
3. Rate update for multiple-sources transfer

The rate of each flow is not fixed all the time. It will dynamicly change along with the change of topology, new transfer coming or a transfer completed. So we have to adjust the flow rates in a periodic manner.

The key part of this scheme is to keep the proportion from different sources. So some of the matrix elements are fractional. The rest part will be the same as the traditional water-filling algorithm. See Example 3.
------------------------------------------------------------------------
4. New tansfer coming

Together with 2 and 3, we can deal with all the multi-sources transfer, regardless the new transfer, the exsiting transfer or both. See Example 4.
------------------------------------------------------------------------
5. *Data volume assignment dynamiclly changing

This one is beyond the real system, is not realistic due to some limit. But we can think about some other scenarios. As this one is the most difficult, we can have more tricks on that. In another word, we can write high-level article based on this one.

I havn't given a completed scheme, but I have some thoughts. The assignment of the transfers are all variables, like {x11,x12...}, {x21,x22,x23..}... Each set is indepentant with each other. So the problem can be solved theoreticly. Independent Component Analysis, linear programming,.... There are many mathmatic tools to choose for us.
See Example 5.