rate=scheduling(topology,ongoing_rate,new_request)
{
	map=mapping(topology,ongoing);
	if(new_request==null)
	{
	rate=update(map);
	return rate;
	}
	else
	{
	new_flow=parsing(new_request);
	rate=new_update(map,new_flow);
	return rate;
	}
}

function mapping:
Use this function to generate the flow_link mapping matrix as shown in the example. The matrix elements are float within [0,1]. Also, a row vecotr will be attached to present the bandwidth limit. If a transfer has multiple sources (can includes multiple flows), then the elements will represent the proportion from different sources.

function update:
This function is an enhanced water-filling algoithm that I proposed to compute the rate of each flow.

function parsing:
To parse the new transfer request. For example, the new transfer has k sources, then there will be k flows with known paths. We use x1,x2,...,xk to denote the fraction from source 1,2,...k, and x1+x2+..+xk=1. Then we generate a matrix with these varibles. The output will be a matrix.

function new_updata:
First, we check the new_flow matrix, if it contains no varible, then we combine it with map matrix, and then just do updat(map).
Else, we can excute my algorithm to compute all the varibles as well as the rates.